// Code generated by github.com/mackee/go-sqlla/v2/cmd/sqlla - DO NOT EDIT.
package example

import (
	"context"
	"strconv"
	"strings"

	"database/sql"
	"github.com/go-sql-driver/mysql"
	"time"

	"github.com/mackee/go-sqlla/v2"
)

type teamSQL struct {
	where sqlla.Where
}

func NewTeamSQL() teamSQL {
	q := teamSQL{}
	return q
}

var teamAllColumns = []string{
	"`id`", "`name`", "`created_at`", "`updated_at`",
}

type teamSelectSQL struct {
	teamSQL
	Columns     []string
	order       string
	limit       *uint64
	offset      *uint64
	isForUpdate bool
}

func (q teamSQL) Select() teamSelectSQL {
	return teamSelectSQL{
		q,
		teamAllColumns,
		"",
		nil,
		nil,
		false,
	}
}

func (q teamSelectSQL) Or(qs ...teamSelectSQL) teamSelectSQL {
	ws := make([]sqlla.Where, 0, len(qs))
	for _, q := range qs {
		ws = append(ws, q.where)
	}
	q.where = append(q.where, sqlla.ExprOr(ws))
	return q
}

func (q teamSelectSQL) Limit(l uint64) teamSelectSQL {
	q.limit = &l
	return q
}

func (q teamSelectSQL) Offset(o uint64) teamSelectSQL {
	q.offset = &o
	return q
}

func (q teamSelectSQL) ForUpdate() teamSelectSQL {
	q.isForUpdate = true
	return q
}

func (q teamSelectSQL) ID(v TeamID, exprs ...sqlla.Operator) teamSelectSQL {
	var op sqlla.Operator
	if len(exprs) == 0 {
		op = sqlla.OpEqual
	} else {
		op = exprs[0]
	}
	where := sqlla.ExprInt64{Value: int64(v), Op: op, Column: "`id`"}
	q.where = append(q.where, where)
	return q
}

func (q teamSelectSQL) IDIn(vs ...TeamID) teamSelectSQL {
	_vs := make([]int64, 0, len(vs))
	for _, v := range vs {
		_vs = append(_vs, int64(v))
	}
	where := sqlla.ExprMultiInt64{Values: _vs, Op: sqlla.MakeInOperator(len(vs)), Column: "`id`"}
	q.where = append(q.where, where)
	return q
}

func (q teamSelectSQL) PkColumn(pk int64, exprs ...sqlla.Operator) teamSelectSQL {
	v := TeamID(pk)
	return q.ID(v, exprs...)
}

func (q teamSelectSQL) OrderByID(order sqlla.Order) teamSelectSQL {
	q.order = " ORDER BY `id`"
	if order == sqlla.Asc {
		q.order += " ASC"
	} else {
		q.order += " DESC"
	}

	return q
}

func (q teamSelectSQL) Name(v string, exprs ...sqlla.Operator) teamSelectSQL {
	var op sqlla.Operator
	if len(exprs) == 0 {
		op = sqlla.OpEqual
	} else {
		op = exprs[0]
	}
	where := sqlla.ExprString{Value: v, Op: op, Column: "`name`"}
	q.where = append(q.where, where)
	return q
}

func (q teamSelectSQL) NameIn(vs ...string) teamSelectSQL {
	where := sqlla.ExprMultiString{Values: vs, Op: sqlla.MakeInOperator(len(vs)), Column: "`name`"}
	q.where = append(q.where, where)
	return q
}

func (q teamSelectSQL) OrderByName(order sqlla.Order) teamSelectSQL {
	q.order = " ORDER BY `name`"
	if order == sqlla.Asc {
		q.order += " ASC"
	} else {
		q.order += " DESC"
	}

	return q
}

func (q teamSelectSQL) CreatedAt(v time.Time, exprs ...sqlla.Operator) teamSelectSQL {
	var op sqlla.Operator
	if len(exprs) == 0 {
		op = sqlla.OpEqual
	} else {
		op = exprs[0]
	}
	where := sqlla.ExprTime{Value: v, Op: op, Column: "`created_at`"}
	q.where = append(q.where, where)
	return q
}

func (q teamSelectSQL) CreatedAtIn(vs ...time.Time) teamSelectSQL {
	where := sqlla.ExprMultiTime{Values: vs, Op: sqlla.MakeInOperator(len(vs)), Column: "`created_at`"}
	q.where = append(q.where, where)
	return q
}

func (q teamSelectSQL) OrderByCreatedAt(order sqlla.Order) teamSelectSQL {
	q.order = " ORDER BY `created_at`"
	if order == sqlla.Asc {
		q.order += " ASC"
	} else {
		q.order += " DESC"
	}

	return q
}

func (q teamSelectSQL) UpdatedAt(v mysql.NullTime, exprs ...sqlla.Operator) teamSelectSQL {
	var op sqlla.Operator
	if len(exprs) == 0 {
		op = sqlla.OpEqual
	} else {
		op = exprs[0]
	}
	where := sqlla.ExprNullTime{Value: v, Op: op, Column: "`updated_at`"}
	q.where = append(q.where, where)
	return q
}

func (q teamSelectSQL) UpdatedAtIn(vs ...mysql.NullTime) teamSelectSQL {
	where := sqlla.ExprMultiNullTime{Values: vs, Op: sqlla.MakeInOperator(len(vs)), Column: "`updated_at`"}
	q.where = append(q.where, where)
	return q
}

func (q teamSelectSQL) OrderByUpdatedAt(order sqlla.Order) teamSelectSQL {
	q.order = " ORDER BY `updated_at`"
	if order == sqlla.Asc {
		q.order += " ASC"
	} else {
		q.order += " DESC"
	}

	return q
}

func (q teamSelectSQL) ToSql() (string, []interface{}, error) {
	columns := strings.Join(q.Columns, ", ")
	wheres, vs, err := q.where.ToSql()
	if err != nil {
		return "", nil, err
	}

	query := "SELECT " + columns + " FROM team"
	if wheres != "" {
		query += " WHERE" + wheres
	}
	query += q.order
	if q.limit != nil {
		query += " LIMIT " + strconv.FormatUint(*q.limit, 10)
	}
	if q.offset != nil {
		query += " OFFSET " + strconv.FormatUint(*q.offset, 10)
	}

	if q.isForUpdate {
		query += " FOR UPDATE"
	}

	return query + ";", vs, nil
}

func (s Team) Select() teamSelectSQL {
	return NewTeamSQL().Select().ID(s.ID)
}
func (q teamSelectSQL) Single(db sqlla.DB) (Team, error) {
	q.Columns = teamAllColumns
	query, args, err := q.ToSql()
	if err != nil {
		return Team{}, err
	}

	row := db.QueryRow(query, args...)
	return q.Scan(row)
}

func (q teamSelectSQL) SingleContext(ctx context.Context, db sqlla.DB) (Team, error) {
	q.Columns = teamAllColumns
	query, args, err := q.ToSql()
	if err != nil {
		return Team{}, err
	}

	row := db.QueryRowContext(ctx, query, args...)
	return q.Scan(row)
}

func (q teamSelectSQL) All(db sqlla.DB) ([]Team, error) {
	rs := make([]Team, 0, 10)
	q.Columns = teamAllColumns
	query, args, err := q.ToSql()
	if err != nil {
		return nil, err
	}

	rows, err := db.Query(query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	for rows.Next() {
		r, err := q.Scan(rows)
		if err != nil {
			return nil, err
		}
		rs = append(rs, r)
	}
	return rs, nil
}

func (q teamSelectSQL) AllContext(ctx context.Context, db sqlla.DB) ([]Team, error) {
	rs := make([]Team, 0, 10)
	q.Columns = teamAllColumns
	query, args, err := q.ToSql()
	if err != nil {
		return nil, err
	}

	rows, err := db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	for rows.Next() {
		r, err := q.Scan(rows)
		if err != nil {
			return nil, err
		}
		rs = append(rs, r)
	}
	return rs, nil
}

func (q teamSelectSQL) Scan(s sqlla.Scanner) (Team, error) {
	var row Team
	err := s.Scan(
		&row.ID,
		&row.Name,
		&row.CreatedAt,
		&row.UpdatedAt,
	)
	return row, err
}

type teamUpdateSQL struct {
	teamSQL
	setMap  sqlla.SetMap
	Columns []string
}

func (q teamSQL) Update() teamUpdateSQL {
	return teamUpdateSQL{
		teamSQL: q,
		setMap:  sqlla.SetMap{},
	}
}

func (q teamUpdateSQL) SetID(v TeamID) teamUpdateSQL {
	q.setMap["`id`"] = v
	return q
}

func (q teamUpdateSQL) WhereID(v TeamID, exprs ...sqlla.Operator) teamUpdateSQL {
	var op sqlla.Operator
	if len(exprs) == 0 {
		op = sqlla.OpEqual
	} else {
		op = exprs[0]
	}
	where := sqlla.ExprInt64{Value: int64(v), Op: op, Column: "`id`"}
	q.where = append(q.where, where)
	return q
}

func (q teamUpdateSQL) WhereIDIn(vs ...TeamID) teamUpdateSQL {
	_vs := make([]int64, 0, len(vs))
	for _, v := range vs {
		_vs = append(_vs, int64(v))
	}
	where := sqlla.ExprMultiInt64{Values: _vs, Op: sqlla.MakeInOperator(len(vs)), Column: "`id`"}
	q.where = append(q.where, where)
	return q
}

func (q teamUpdateSQL) SetName(v string) teamUpdateSQL {
	q.setMap["`name`"] = v
	return q
}

func (q teamUpdateSQL) WhereName(v string, exprs ...sqlla.Operator) teamUpdateSQL {
	var op sqlla.Operator
	if len(exprs) == 0 {
		op = sqlla.OpEqual
	} else {
		op = exprs[0]
	}
	where := sqlla.ExprString{Value: v, Op: op, Column: "`name`"}
	q.where = append(q.where, where)
	return q
}

func (q teamUpdateSQL) WhereNameIn(vs ...string) teamUpdateSQL {
	where := sqlla.ExprMultiString{Values: vs, Op: sqlla.MakeInOperator(len(vs)), Column: "`name`"}
	q.where = append(q.where, where)
	return q
}

func (q teamUpdateSQL) SetCreatedAt(v time.Time) teamUpdateSQL {
	q.setMap["`created_at`"] = v
	return q
}

func (q teamUpdateSQL) WhereCreatedAt(v time.Time, exprs ...sqlla.Operator) teamUpdateSQL {
	var op sqlla.Operator
	if len(exprs) == 0 {
		op = sqlla.OpEqual
	} else {
		op = exprs[0]
	}
	where := sqlla.ExprTime{Value: v, Op: op, Column: "`created_at`"}
	q.where = append(q.where, where)
	return q
}

func (q teamUpdateSQL) WhereCreatedAtIn(vs ...time.Time) teamUpdateSQL {
	where := sqlla.ExprMultiTime{Values: vs, Op: sqlla.MakeInOperator(len(vs)), Column: "`created_at`"}
	q.where = append(q.where, where)
	return q
}

func (q teamUpdateSQL) SetUpdatedAt(v mysql.NullTime) teamUpdateSQL {
	q.setMap["`updated_at`"] = v
	return q
}

func (q teamUpdateSQL) WhereUpdatedAt(v mysql.NullTime, exprs ...sqlla.Operator) teamUpdateSQL {
	var op sqlla.Operator
	if len(exprs) == 0 {
		op = sqlla.OpEqual
	} else {
		op = exprs[0]
	}
	where := sqlla.ExprNullTime{Value: v, Op: op, Column: "`updated_at`"}
	q.where = append(q.where, where)
	return q
}

func (q teamUpdateSQL) WhereUpdatedAtIn(vs ...mysql.NullTime) teamUpdateSQL {
	where := sqlla.ExprMultiNullTime{Values: vs, Op: sqlla.MakeInOperator(len(vs)), Column: "`updated_at`"}
	q.where = append(q.where, where)
	return q
}

func (q teamUpdateSQL) ToSql() (string, []interface{}, error) {
	var err error
	var s interface{} = Team{}
	if t, ok := s.(teamDefaultUpdateHooker); ok {
		q, err = t.DefaultUpdateHook(q)
		if err != nil {
			return "", []interface{}{}, err
		}
	}
	setColumns, svs, err := q.setMap.ToUpdateSql()
	if err != nil {
		return "", []interface{}{}, err
	}
	wheres, wvs, err := q.where.ToSql()
	if err != nil {
		return "", []interface{}{}, err
	}

	query := "UPDATE team SET" + setColumns
	if wheres != "" {
		query += " WHERE" + wheres
	}

	return query + ";", append(svs, wvs...), nil
}
func (s Team) Update() teamUpdateSQL {
	return NewTeamSQL().Update().WhereID(s.ID)
}

func (q teamUpdateSQL) Exec(db sqlla.DB) ([]Team, error) {
	query, args, err := q.ToSql()
	if err != nil {
		return nil, err
	}
	_, err = db.Exec(query, args...)
	if err != nil {
		return nil, err
	}
	qq := q.teamSQL

	return qq.Select().All(db)
}

func (q teamUpdateSQL) ExecContext(ctx context.Context, db sqlla.DB) ([]Team, error) {
	query, args, err := q.ToSql()
	if err != nil {
		return nil, err
	}
	_, err = db.ExecContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	qq := q.teamSQL

	return qq.Select().AllContext(ctx, db)
}

type teamDefaultUpdateHooker interface {
	DefaultUpdateHook(teamUpdateSQL) (teamUpdateSQL, error)
}

type teamInsertSQL struct {
	teamSQL
	setMap  sqlla.SetMap
	Columns []string
}

func (q teamSQL) Insert() teamInsertSQL {
	return teamInsertSQL{
		teamSQL: q,
		setMap:  sqlla.SetMap{},
	}
}

func (q teamInsertSQL) ValueID(v TeamID) teamInsertSQL {
	q.setMap["`id`"] = v
	return q
}

func (q teamInsertSQL) ValueName(v string) teamInsertSQL {
	q.setMap["`name`"] = v
	return q
}

func (q teamInsertSQL) ValueCreatedAt(v time.Time) teamInsertSQL {
	q.setMap["`created_at`"] = v
	return q
}

func (q teamInsertSQL) ValueUpdatedAt(v mysql.NullTime) teamInsertSQL {
	q.setMap["`updated_at`"] = v
	return q
}

func (q teamInsertSQL) ToSql() (string, []interface{}, error) {
	var err error
	var s interface{} = Team{}
	if t, ok := s.(teamDefaultInsertHooker); ok {
		q, err = t.DefaultInsertHook(q)
		if err != nil {
			return "", []interface{}{}, err
		}
	}
	qs, vs, err := q.setMap.ToInsertSql()
	if err != nil {
		return "", []interface{}{}, err
	}

	query := "INSERT INTO team " + qs

	return query + ";", vs, nil
}

func (q teamInsertSQL) Exec(db sqlla.DB) (Team, error) {
	query, args, err := q.ToSql()
	if err != nil {
		return Team{}, err
	}
	result, err := db.Exec(query, args...)
	if err != nil {
		return Team{}, err
	}
	id, err := result.LastInsertId()
	if err != nil {
		return Team{}, err
	}
	return NewTeamSQL().Select().PkColumn(id).Single(db)
}

func (q teamInsertSQL) ExecContext(ctx context.Context, db sqlla.DB) (Team, error) {
	query, args, err := q.ToSql()
	if err != nil {
		return Team{}, err
	}
	result, err := db.ExecContext(ctx, query, args...)
	if err != nil {
		return Team{}, err
	}
	id, err := result.LastInsertId()
	if err != nil {
		return Team{}, err
	}
	return NewTeamSQL().Select().PkColumn(id).SingleContext(ctx, db)
}

type teamDefaultInsertHooker interface {
	DefaultInsertHook(teamInsertSQL) (teamInsertSQL, error)
}

type teamDeleteSQL struct {
	teamSQL
}

func (q teamSQL) Delete() teamDeleteSQL {
	return teamDeleteSQL{
		q,
	}
}

func (q teamDeleteSQL) ID(v TeamID, exprs ...sqlla.Operator) teamDeleteSQL {
	var op sqlla.Operator
	if len(exprs) == 0 {
		op = sqlla.OpEqual
	} else {
		op = exprs[0]
	}
	where := sqlla.ExprInt64{Value: int64(v), Op: op, Column: "`id`"}
	q.where = append(q.where, where)
	return q
}

func (q teamDeleteSQL) IDIn(vs ...TeamID) teamDeleteSQL {
	_vs := make([]int64, 0, len(vs))
	for _, v := range vs {
		_vs = append(_vs, int64(v))
	}
	where := sqlla.ExprMultiInt64{Values: _vs, Op: sqlla.MakeInOperator(len(vs)), Column: "`id`"}
	q.where = append(q.where, where)
	return q
}

func (q teamDeleteSQL) Name(v string, exprs ...sqlla.Operator) teamDeleteSQL {
	var op sqlla.Operator
	if len(exprs) == 0 {
		op = sqlla.OpEqual
	} else {
		op = exprs[0]
	}
	where := sqlla.ExprString{Value: v, Op: op, Column: "`name`"}
	q.where = append(q.where, where)
	return q
}

func (q teamDeleteSQL) NameIn(vs ...string) teamDeleteSQL {
	where := sqlla.ExprMultiString{Values: vs, Op: sqlla.MakeInOperator(len(vs)), Column: "`name`"}
	q.where = append(q.where, where)
	return q
}

func (q teamDeleteSQL) CreatedAt(v time.Time, exprs ...sqlla.Operator) teamDeleteSQL {
	var op sqlla.Operator
	if len(exprs) == 0 {
		op = sqlla.OpEqual
	} else {
		op = exprs[0]
	}
	where := sqlla.ExprTime{Value: v, Op: op, Column: "`created_at`"}
	q.where = append(q.where, where)
	return q
}

func (q teamDeleteSQL) CreatedAtIn(vs ...time.Time) teamDeleteSQL {
	where := sqlla.ExprMultiTime{Values: vs, Op: sqlla.MakeInOperator(len(vs)), Column: "`created_at`"}
	q.where = append(q.where, where)
	return q
}

func (q teamDeleteSQL) UpdatedAt(v mysql.NullTime, exprs ...sqlla.Operator) teamDeleteSQL {
	var op sqlla.Operator
	if len(exprs) == 0 {
		op = sqlla.OpEqual
	} else {
		op = exprs[0]
	}
	where := sqlla.ExprNullTime{Value: v, Op: op, Column: "`updated_at`"}
	q.where = append(q.where, where)
	return q
}

func (q teamDeleteSQL) UpdatedAtIn(vs ...mysql.NullTime) teamDeleteSQL {
	where := sqlla.ExprMultiNullTime{Values: vs, Op: sqlla.MakeInOperator(len(vs)), Column: "`updated_at`"}
	q.where = append(q.where, where)
	return q
}

func (q teamDeleteSQL) ToSql() (string, []interface{}, error) {
	wheres, vs, err := q.where.ToSql()
	if err != nil {
		return "", nil, err
	}

	query := "DELETE FROM team"
	if wheres != "" {
		query += " WHERE" + wheres
	}

	return query + ";", vs, nil
}

func (q teamDeleteSQL) Exec(db sqlla.DB) (sql.Result, error) {
	query, args, err := q.ToSql()
	if err != nil {
		return nil, err
	}
	return db.Exec(query, args...)
}

func (q teamDeleteSQL) ExecContext(ctx context.Context, db sqlla.DB) (sql.Result, error) {
	query, args, err := q.ToSql()
	if err != nil {
		return nil, err
	}
	return db.ExecContext(ctx, query, args...)
}
func (s Team) Delete(db sqlla.DB) (sql.Result, error) {
	query, args, err := NewTeamSQL().Delete().ID(s.ID).ToSql()
	if err != nil {
		return nil, err
	}
	return db.Exec(query, args...)
}

func (s Team) DeleteContext(ctx context.Context, db sqlla.DB) (sql.Result, error) {
	query, args, err := NewTeamSQL().Delete().ID(s.ID).ToSql()
	if err != nil {
		return nil, err
	}
	return db.ExecContext(ctx, query, args...)
}
